% Build the stan command line
% note how init is handled for multiple chains
% https://groups.google.com/forum/?fromgroups#!searchin/stan-users/command$20line/stan-users/2YNalzIGgEs/NbbDsM9R9PMJ
% bash script for stan
% https://groups.google.com/forum/?fromgroups#!topic/stan-dev/awcXvXxIfHg

% Notes
%Initial version is a wrapper for stan cmd-line.
classdef stan < handle
   properties(GetAccess = public, SetAccess = public)
      stanHome = '/Users/brian/Downloads/stan-2.0.1/';
%      compileOptions

%      model = 'bernoulli';
%       modelPath = '/Users/brian/Downloads/stan-2.0.1/src/models/basic_estimators/';
%       workingDir = '/Users/brian/Downloads/stan-2.0.1/src/models/basic_estimators/';
      workingDir
      modelPath
      model

      method
      data % need to handle matrix versus filename, should have a callback
      pars
      chains
      
      clean % get rid of generated files
   end
   
   properties(GetAccess = public, SetAccess = private, Dependent = true, Transient = true)
      
      % Expose the same parameters as Rstan and Pystan
      % quick access, use a setter to place these into struct
      % currently, only only those parameters in command-line stan are
      % included here, others, which may be relevant, are above?
      id 
      iter %
      warmup
      thin
      init
      seed      
      
      output
      command
   end
   
   properties(GetAccess = public, SetAccess = public)
      % eventually private
      params
      defaults
      validators
      processes % processManager
      data_ % filename for file autogenerated from data
      output_ % filename for samples
   end

   methods
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %% Constructor      
      function self = stan(varargin)
         [self.defaults,self.validators] = self.stanParams();
         self.params = self.defaults;
         self.modelPath = [pwd filesep];
         self.workingDir = [pwd filesep];
         if nargin == 0
            return;
         end
      
         p = inputParser;
         p.KeepUnmatched= true;
         p.FunctionName = 'stan constructor';
         p.addParamValue('model','',@ischar);
         p.addParamValue('modelPath',[pwd filesep],@(x) exist(x,'dir')==7);
         p.addParamValue('workingDir',[pwd filesep],@(x) exist(x,'dir')==7);
         p.addParamValue('method','sample',@(x) validatestring(x,{'sample' 'optimize' 'diagnose'}));
         p.parse(varargin{:});

         if any(strncmp('data',p.Results.model,4)) && any(strncmp('parameters',p.Results.model,10)) && any(strncmp('model',p.Results.model,5))
            % model string, assuming model is a cell array of strings
            % writeModel()
            % store filename in model_?
         else
            % filename, may need to strip of .stan extension?
            self.model = p.Results.model;
         end
         self.modelPath = p.Results.modelPath;
         
         % check that we can write to the working and model directories?
         % otherwise set to tempdir
         self.workingDir = p.Results.workingDir;
         
         self.method = p.Results.method;
         
         % pass remaining inputs to set()
         self.set(p.Unmatched);
      end
      
      function id = get.id(self)
         id = self.params.id;
      end
      function iter = get.iter(self)
         iter = self.params.sample.num_samples;
      end
      function warmup = get.warmup(self)
         warmup = self.params.sample.num_warmup;
      end
      function thin = get.thin(self)
         thin = self.params.sample.thin;
      end
      function init = get.init(self)
         init = self.params.init;
      end
      function seed = get.seed(self)
         seed = self.params.random.seed;
      end
%       function data_ = get.data_(self)
%          data_ = self.params.data.file;
%       end
      function output_ = get.output_(self)
         output_ = self.params.output.file;
      end
      
      function command = get.command(self)
         % add a prefix and postfix property according to os
         command = {['./' self.model ' ']};
         str = parseParams(self.params,self.method);
         command = cat(1,command,str);
      end
      
      function set(self,varargin)
         va = @validateattributes;
         d = self.defaults;
         v = self.validators;
         
         p = inputParser;
         p.KeepUnmatched= false;
         p.FunctionName = 'stan parameter setter';
         p.addParamValue('id',d.id,@(x) va(x,v.id{1},v.id{2}));
         p.addParamValue('iter',d.sample.num_samples,@(x) va(x,v.sample.num_samples{1},v.sample.num_samples{2}));
         p.addParamValue('warmup',d.sample.num_warmup,@(x) va(x,v.sample.num_warmup{1},v.sample.num_warmup{2}));
         p.addParamValue('thin',d.sample.thin,@(x) va(x,v.sample.thin{1},v.sample.thin{2}));
         p.addParamValue('init',d.init,@(x) va(x,v.init{1},v.init{2}));
         p.addParamValue('seed',d.random.seed,@(x) va(x,v.random.seed{1},v.random.seed{2}));
         %p.addParamValue('data',d.data.file,v.data.file);
         p.addParamValue('data',[],@(x) isstruct(x) || isstr(x));
         p.parse(varargin{:});

         self.params.sample.num_samples = p.Results.iter;
         self.params.sample.num_warmup = p.Results.warmup;
         self.params.sample.thin = p.Results.thin;
         self.params.init = p.Results.init;
         self.params.random.seed = p.Results.seed;
         
         if isstruct(p.Results.data)
            % rdump()
         elseif ischar(p.Results.data)
            % name of data file
            %keyboard
            % read data into struct... what a mess...            
            % self.data = dump2struct()
            self.data = 'file';
            % store filename in self.data_
            %keyboard
            self.data_ = p.Results.data;
            % insert filename into params.data.file
            self.params.data.file = self.data_;
         else
            
         end
         %self.params.data.file = p.Results.data;
         %self.data_ = p.Results.data;
      end
      
      function fit = run(self)
         fprintf('Starting stan');
         if strcmp(self.method,'sample')
            fprintf('sampling with %g chains...\n',self.chains);
         end
%          for i = 1:self.chains
%             self.p(i) = processManager('id','stan','command',self.command,...
%                                'workingDir',self.modelPath,...
%                                'wrap',100,...
%                                'keepStdout',false,...
%                                'pollInterval',1,...
%                                'printStdout',true);
%          end
         command = sprintf('%s',self.command{:});

            self.processes = processManager('id','stan','command',command,...
                               'workingDir',self.modelPath,...
                               'wrap',100,...
                               'keepStdout',false,...
                               'pollInterval',1,...
                               'printStdout',true);
         if nargout == 1
            fit = stanFit(self.processes);
            fit.output_ = self.output_;
         end
      end
      
      function self = print(self,file)
         % this should allow multiple files and regexp. 
         % note that passing regexp through in the command does not work,
         % need to implment search in matlab
         if nargin < 2
            file = self.params.output.file;
         end
         command = [self.stanHome 'bin/print ' file];
         p = processManager('command',command,...
                            'workingDir',self.workingDir,...
                            'wrap',100,...
                            'keepStdout',false);
         p.block(0.05);
      end
      
      function help(self,str)
         % if str is stanc or other basic binary
         
         %else
         % need to check that model binary exists
         command = [[self.modelPath self.model] ' ' str ' help'];
         p = processManager('id','stan help','command',command,...
                            'workingDir',self.modelPath,...
                            'wrap',100,...
                            'keepStdout',true,...
                            'printStdout',false);
         p.block(0.05);
         if p.exitValue == 0
            % Trim off the boilerplate
            ind = find(strncmp('Usage: ',p.stdout,7));
            fprintf('%s\n',p.stdout{1:ind-1});
         else
            fprintf('%s\n',p.stdout{:});
         end
      end
      
      function self = compile(self,target)
         if any(strcmp({'stanc' 'libstan.a' 'libstanc.a' 'print'},target))
            command = ['make bin/' target];
            printStderr = false;
         elseif strcmp(target,'model')
            command = ['make ' self.modelPath self.model];
            printStderr = true;
         else
            error('Unknown target');
         end
         p = processManager('id','compile',...
                            'command',command,...
                            'workingDir',self.stanHome,...
                            'printStderr',printStderr,...
                            'keepStderr',true,...
                            'keepStdout',true);
         p.block(0.05);
      end
      
      function [hdr,varNames,samples] = extract(self)
         fid = fopen(self.output_);
         
         [hdr,varNames,samples] = self.readStanCsv(fid);
         
         fclose(fid);
         
      end
      

   end

   methods(Static)
      function [params,valid] = stanParams()
         % Default Stan parameters and validators
         % validator can be
         % 1) function handle
         % 2) 1x2 cell array of cells, input to validateattributes first element is classes,
         % second is attributes
         % 3) cell array of strings representing valid arguments
         params.sample = struct(...
                               'num_samples',1000,...
                               'num_warmup',1000,...
                               'save_warmup',false,...
                               'thin',1,...
                               'adapt',struct(...
                                              'engaged',true,...
                                              'gamma',0.05,...
                                              'delta',0.65,...
                                              'kappa',0.75,...
                                              't0',10),...
                               'algorithm','hmc',...
                               'hmc',struct(...
                                            'engine','nuts',...
                                            'static',struct('int_time',2*pi),...
                                            'nuts',struct('max_depth',10),...
                                            'metric','diag_e',...
                                            'stepsize',1,...
                                            'stepsize_jitter',0));
         valid.sample = struct(...
                               'num_samples',{{{'numeric'} {'scalar','>=',0}}},...
                               'num_warmup',{{{'numeric'} {'scalar','>=',0}}},...
                               'save_warmup',{{{'logical'} {'scalar'}}},...
                               'thin',{{{'numeric'} {'scalar','>',0}}},...
                               'adapt',struct(...
                                              'engaged',{{{'logical'} {'scalar'}}},...
                                              'gamma',{{{'numeric'} {'scalar','>',0}}},...
                                              'delta',{{{'numeric'} {'scalar','>',0}}},...
                                              'kappa',{{{'numeric'} {'scalar','>',0}}},...
                                              't0',{{{'numeric'} {'scalar','>',0}}}),...
                               'algorithm',{{'hmc'}},...
                               'hmc',struct(...
                                            'engine',{{'static' 'nuts'}},...
                                            'static',struct('int_time',{{{'numeric'} {'scalar','>',0}}}),...
                                            'nuts',struct('max_depth',{{{'numeric'} {'scalar','>',0}}}),...
                                            'metric',{{'unit_e' 'diag_e' 'dense_e'}},...
                                            'stepsize',1,...
                                            'stepsize_jitter',0));

         params.optimize = struct(...
                                 'algorithm','bfgs',...
                                 'nesterov',struct(...
                                                   'stepsize',1),...
                                 'bfgs',struct(...
                                               'init_alpha',0.001,...
                                               'tol_obj',1e-8,...
                                               'tol_grad',1e-8,...
                                               'tol_param',1e-8),...
                                 'iter',2000,...
                                 'save_iterations',false);

         valid.optimize = struct(...
                                 'algorithm',{{'nesterov' 'bfgs' 'newton'}},...
                                 'nesterov',struct(...
                                                   'stepsize',{{{'numeric'} {'scalar','>',0}}}),...
                                 'bfgs',struct(...
                                               'init_alpha',{{{'numeric'} {'scalar','>',0}}},...
                                               'tol_obj',{{{'numeric'} {'scalar','>',0}}},...
                                               'tol_grad',{{{'numeric'} {'scalar','>',0}}},...
                                               'tol_param',{{{'numeric'} {'scalar','>',0}}}),...
                                 'iter',{{{'numeric'} {'scalar','>',0}}},...
                                 'save_iterations',{{{'logical'} {'scalar'}}});

         params.diagnose = struct(...
                                 'test','gradient');
         valid.diagnose = struct(...
                                 'test',{{{'gradient'}}});

         params.id = 1; % 0 doesnot work as default
         valid.id = {{'numeric'} {'scalar','>',0}};
         params.data = struct('file','');
         valid.data = struct('file',@isstr);
         params.init = 2;
         valid.init = {{'numeric' 'char'} {'nonempty'}}; % shitty validator
         params.random = struct('seed',-1);
         valid.random = struct('seed',{{{'numeric'} {'scalar'}}});

         params.output = struct(...
                                'file','samples.csv',...
                                'append_sample',false,...
                                'diagnostic_file','',...
                                'append_diagnostic',false,...
                                'refresh',100);
         valid.output = struct(...
                                'file',@isstr,...
                                'append_sample',{{{'logical'} {'scalar'}}},...
                                'diagnostic_file',@isstr,...
                                'append_diagnostic',{{{'logical'} {'scalar'}}},...
                                'refresh',{{{'numeric'} {'scalar','>',0}}});
      end
      
   end
end

% Generate command string from parameter structure. Very inefficient...
% root = 'sample' 'optimize' or 'diagnose'
% return a containers.Map?
function str = parseParams(s,root)
   branch = {'sample' 'optimize' 'diagnose' 'static' 'nuts' 'nesterov' 'bfgs'};
   if nargin == 2
      branch = branch(~strcmp(branch,root));
      fn = fieldnames(s);
      d = intersect(fn,branch);
      s = rmfield(s,d);
   end

   fn = fieldnames(s);
   val = '';
   str = {};
   for i = 1:numel(fn)
      try
         if isstruct(s.(fn{i}))
            % If any of the fieldnames match the *previous* value, assume the
            % previous value is a selector from amongst the fielnames, and
            % delete the other branches
            if any(strcmp(fieldnames(s),val))
               root = val;
               branch = branch(~strcmp(branch,root));
               d = intersect(fieldnames(s),branch);
               s = rmfield(s,d);

               str2 = parseParams(s.(root));
               s = rmfield(s,root);
               str = cat(1,str,str2);
            else
               if ~strcmp(fn{i},val)
                  str = cat(1,str,{sprintf('%s ',fn{i})});
                  %fprintf('%s \\\n',fn{i});
               end
               str2 = parseParams(s.(fn{i}));
               str = cat(1,str,str2);
            end
         else
            val = s.(fn{i});
            if isnumeric(val) || islogical(val)
               val = num2str(val);
            end
            str = cat(1,str,{sprintf('%s=%s ',fn{i},val)});
            %fprintf('%s=%s \\\n',fn{i},val);
         end
      catch
         % We trimmed a branch,
         %fprintf('dropping\n')
      end
   end
end
